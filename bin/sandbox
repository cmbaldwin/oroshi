#!/usr/bin/env bash
#
# Oroshi Sandbox Management Script
# =================================
#
# This script creates, manages, and destroys a sandbox Rails application for
# testing and developing the Oroshi engine gem. The sandbox is a complete,
# standalone Rails application that mounts the Oroshi engine.
#
# ARCHITECTURE:
# - Oroshi is a Rails engine gem (lib/oroshi/engine.rb)
# - The sandbox is a fresh Rails application that includes Oroshi as a gem
# - Routes are GENERATED (not copied) to demonstrate proper engine mounting
# - Multi-database setup: primary, queue (Solid Queue), cache, cable
#
# WHY NOT RUN rails new INSIDE THE ENGINE?
# - Running 'rails new' from within an existing Rails directory fails
# - The script creates the app in /tmp first, then moves it to ./sandbox
# - This follows the Solidus pattern: https://github.com/solidusio/solidus
#
# UNBUNDLED EXECUTION:
# - Commands must run outside the parent's Bundler environment
# - Otherwise, the sandbox would inherit the engine's gem constraints
# - The unbundled() function handles this cleanly
#
# Usage:
#   bin/sandbox           # Create sandbox (default)
#   bin/sandbox reset     # Destroy and recreate
#   bin/sandbox destroy   # Remove sandbox
#   bin/sandbox help      # Show help
#
# Environment Variables:
#   DB=postgresql|mysql   # Database adapter (default: postgresql)
#
# After creation, start the sandbox:
#   cd sandbox && bin/dev
#   Visit: http://localhost:3000
#   Login: admin@oroshi.local / password123
#
set -e  # Exit on any error
set -u  # Exit on undefined variables
set -o pipefail  # Catch errors in pipes

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Unbundled function - run commands outside the parent's bundler environment
# This is critical for engine development to avoid gem loading conflicts.
# Without this, the sandbox would inherit oroshi's Gemfile.lock constraints,
# causing version conflicts and initialization issues.
# Adapted from Solidus: https://github.com/solidusio/solidus/blob/main/bin/sandbox
unbundled() {
  ruby -rbundler -e'
    Gem::Version.new(Bundler::VERSION) < Gem::Version.new("2.1") ?
      abort("The sandbox requires at least Bundler 2.1") :
      Bundler.with_unbundled_env { system(*ARGV) }' -- \
        env BUNDLE_SUPPRESS_INSTALL_USING_MESSAGES=true "$@"
}

# Show help message with usage examples
show_help() {
  cat <<EOF
Oroshi Sandbox Management
=========================

Creates a standalone Rails application for testing and developing the
Oroshi engine gem. The sandbox is generated fresh each time, not copied.

Usage:
  bin/sandbox [command]

Commands:
  create    Create a new sandbox application (default)
  destroy   Remove the sandbox application
  reset     Destroy and recreate the sandbox application
  help      Show this help message

Environment Variables:
  DB        Database adapter (postgresql, mysql) - default: postgresql

Examples:
  bin/sandbox              # Create sandbox with PostgreSQL
  bin/sandbox reset        # Recreate sandbox from scratch
  bin/sandbox destroy      # Remove sandbox completely
  DB=mysql bin/sandbox     # Create sandbox with MySQL

After Creation:
  cd sandbox
  bin/dev
  # Visit: http://localhost:3001
  # Login: admin@oroshi.local / password123

Notes:
  - Sandbox runs on port 3001 (not 3000) to avoid conflicts with dev server
  - The sandbox is NOT committed to git (.gitignore)
  - Routes are generated, not copied, to show proper engine mounting
  - Multi-database setup for Solid Queue/Cache/Cable is configured automatically

EOF
}

# Remove the sandbox directory
destroy_sandbox() {
  if [ -d "./sandbox" ]; then
    echo "ðŸ§¹ Removing sandbox..."
    rm -rf ./sandbox
    echo "âœ… Sandbox removed"
  else
    echo "â„¹ï¸  No sandbox found"
  fi
}

# =============================================================================
# COMMAND HANDLING
# =============================================================================

COMMAND="${1:-create}"

case "$COMMAND" in
  help|-h|--help)
    show_help
    exit 0
    ;;
  destroy)
    destroy_sandbox
    exit 0
    ;;
  reset)
    destroy_sandbox
    # Continue to create
    ;;
  create)
    # Continue to create
    ;;
  *)
    echo "âŒ Unknown command: $COMMAND"
    echo "Run 'bin/sandbox help' for usage"
    exit 1
    ;;
esac

# =============================================================================
# SANDBOX CREATION
# =============================================================================

echo "ðŸ—ï¸  Creating Oroshi sandbox application..."

# Detect database from environment (default to postgresql if not set)
# PostgreSQL is preferred for the multi-database Solid Queue/Cache/Cable setup
DB="${DB:-postgresql}"

case "$DB" in
  postgres|postgresql)
    RAILSDB="postgresql"
    ;;
  mysql)
    RAILSDB="mysql"
    ;;
  *)
    RAILSDB="postgresql"
    ;;
esac

# Clean slate - remove any existing sandbox
if [ -d "./sandbox" ]; then
  echo "ðŸ§¹ Removing existing sandbox..."
  rm -rf ./sandbox
fi

# Get the absolute path to the oroshi root directory
# This is needed to reference the engine after cd-ing elsewhere
OROSHI_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# =============================================================================
# RAILS APP GENERATION
# =============================================================================
#
# Generate the Rails app in a TEMPORARY directory first, then move it.
# This is required because 'rails new' fails when run from within an
# existing Rails directory (it detects the parent Gemfile/Rakefile).
#
echo "ðŸ“¦ Generating new Rails application..."
TEMP_DIR=$(mktemp -d)
cd "$TEMP_DIR"

# Generate a minimal Rails app:
# --skip-git: We don't want a nested .git directory
# --skip-keeps: No .keep files needed for demo
# --skip-rc: No need for Rails credentials in sandbox
# --skip-test: We'll use RSpec if testing sandbox directly
# --skip-asset-pipeline: We add Propshaft separately (more control)
# --javascript=importmap: Modern Rails 8 approach (no Node.js/Webpack)
rails new sandbox \
  --database="$RAILSDB" \
  --skip-git \
  --skip-keeps \
  --skip-rc \
  --skip-test \
  --skip-asset-pipeline \
  --javascript=importmap

# Move the generated app back to the oroshi directory
mv sandbox "$OROSHI_ROOT/"
cd "$OROSHI_ROOT/sandbox"

# Clean up temp directory
rm -rf "$TEMP_DIR"

# =============================================================================
# GEMFILE CONFIGURATION
# =============================================================================
#
# Add Oroshi and required dependencies to the Gemfile.
# The engine is referenced via 'path: ".."' for local development.
#
echo "ðŸ“ Adding Oroshi to Gemfile..."
cat <<RUBY >> Gemfile

# Asset pipeline (required since we used --skip-asset-pipeline)
gem "propshaft"

# Oroshi engine (local development) - must be loaded in all environments
# The engine provides: Solid Queue, Solid Cache, Solid Cable, Devise, etc.
gem "oroshi", path: "..", require: "oroshi"

# Required for Rails asset watching in development
gem "listen", "~> 3.3"

# Development tools
group :development, :test do
  gem "rspec-rails"
  gem "factory_bot_rails"
end

group :development do
  gem "better_errors"
  # binding_of_caller not compatible with Ruby 4.0
  # gem "binding_of_caller"
end
RUBY

# Bundle install (unbundled to avoid inheriting parent's gem environment)
echo "ðŸ“¦ Installing gems..."
unbundled bundle install --quiet

# =============================================================================
# INITIALIZERS
# =============================================================================
#
# Create initializers for Oroshi and Devise.
# These are wrapped in `if defined?(GemName)` checks to prevent errors
# during db:create/db:migrate when gems may not be fully loaded yet.
#

# Oroshi configuration
echo "âš™ï¸  Configuring Oroshi..."
cat > config/initializers/oroshi.rb <<RUBY
# Oroshi Engine Configuration
# ===========================
# Configure the Oroshi wholesale order management engine.
# See Oroshi::Configuration for available options.

if defined?(Oroshi)
  Oroshi.configure do |config|
    config.time_zone = "Asia/Tokyo"
    config.locale = :ja
    config.domain = ENV.fetch("OROSHI_DOMAIN", "localhost")
  end

  # Sync Rails configuration with Oroshi settings
  Rails.application.config.time_zone = Oroshi.configuration.time_zone
  Rails.application.config.active_record.default_timezone = :utc
  Rails.application.config.i18n.default_locale = Oroshi.configuration.locale
  Rails.application.config.i18n.available_locales = [:ja, :en]
end
RUBY

# Devise configuration (authentication)
echo "ðŸ” Configuring Devise..."
cat > config/initializers/devise.rb <<'RUBY'
# Devise Authentication Configuration
# ====================================
# Wrapped in `if defined?(Devise)` to prevent errors during db:create
# when the Devise railtie may not be fully loaded yet.

if defined?(Devise)
  Devise.setup do |config|
    config.secret_key = Rails.application.credentials.secret_key_base || ENV.fetch('DEVISE_KEY', 'sandbox_dev_key')
    config.mailer_sender = ENV.fetch('MAIL_SENDER', 'noreply@localhost')
    config.mailer = 'Devise::Mailer'
    config.parent_mailer = 'ActionMailer::Base'
    require 'devise/orm/active_record'
    config.authentication_keys = [:login]
    config.case_insensitive_keys = [:email]
    config.strip_whitespace_keys = [:email]
    config.skip_session_storage = [:http_auth]
    config.stretches = Rails.env.test? ? 1 : 11
    config.send_email_changed_notification = false
    config.send_password_change_notification = false
    config.confirm_within = 3.days
    config.reconfirmable = false
    config.confirmation_keys = [:email]
    config.expire_all_remember_me_on_sign_out = true
    config.password_length = 6..128
    config.email_regexp = /\A[^@\s]+@[^@\s]+\z/
    config.scoped_views = true
    config.sign_out_via = :delete
  end
end
RUBY

# =============================================================================
# ROUTES CONFIGURATION
# =============================================================================
#
# IMPORTANT: Routes are GENERATED here, not copied from the engine.
# This demonstrates the proper way for parent applications to mount Oroshi.
#
# The engine provides:
#   - All Oroshi routes under the mounted path
#   - Dashboard, orders, products, buyers, etc.
#
# The parent app provides:
#   - Devise routes (User model is at the application level)
#   - Root route and any custom routes
#   - Health check for Kamal/Docker deployments
#
echo "ðŸ”Œ Setting up routes..."
cat > config/routes.rb <<'RUBY'
# Sandbox Application Routes
# ==========================
#
# This file demonstrates how to mount the Oroshi engine in a parent Rails app.
# These routes are GENERATED by the sandbox script, not copied from the engine.
#
# The pattern is:
#   1. Define application-level routes (health check, Devise, etc.)
#   2. Mount the Oroshi engine at a path (typically /oroshi)
#   3. Optionally redirect root to the engine dashboard
#

Rails.application.routes.draw do
  # Health check endpoint for Kamal/Docker deployments
  get "up" => "rails/health#show", as: :rails_health_check

  # Devise routes for User authentication
  # The User model lives at the application level (not inside the engine)
  # This allows parent apps to customize the User model as needed
  devise_for :users if respond_to?(:devise_for)

  # Mount Oroshi engine at /oroshi
  # All engine routes are accessible under this path:
  #   /oroshi           -> Dashboard
  #   /oroshi/orders    -> Orders
  #   /oroshi/products  -> Products
  #   /oroshi/buyers    -> Buyers
  #   etc.
  mount Oroshi::Engine, at: "/oroshi"

  # Root redirects to Oroshi dashboard
  # In a real app, you might have a landing page here instead
  root to: redirect("/oroshi")
end
RUBY

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
#
# Oroshi uses a multi-database setup for Solid Queue, Cache, and Cable.
# This is the recommended Rails 8 approach for background jobs and caching.
#
echo "ðŸ—„ï¸  Configuring multi-database setup..."
cat > config/database.yml <<YAML
# Multi-Database Configuration for Oroshi
# ========================================
#
# Oroshi uses 4 PostgreSQL databases:
#   - primary: Main application data (orders, products, buyers, etc.)
#   - queue: Solid Queue job storage
#   - cache: Solid Cache entries
#   - cable: Solid Cable (Action Cable) messages
#
# This is the recommended Rails 8 approach for background processing.
#

default: &default
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  host: localhost
  username: <%= ENV.fetch("POSTGRES_USER", "postgres") %>
  password: <%= ENV.fetch("POSTGRES_PASSWORD", "") %>

development:
  primary:
    <<: *default
    database: oroshi_sandbox_development
  queue:
    <<: *default
    database: oroshi_sandbox_development_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_development_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_development_cable
    migrations_paths: db/cable_migrate

test:
  primary:
    <<: *default
    database: oroshi_sandbox_test
  queue:
    <<: *default
    database: oroshi_sandbox_test_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_test_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_test_cable
    migrations_paths: db/cable_migrate

production:
  primary:
    <<: *default
    database: oroshi_sandbox_production
  queue:
    <<: *default
    database: oroshi_sandbox_production_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_production_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_production_cable
    migrations_paths: db/cable_migrate
YAML

# =============================================================================
# ASSET SETUP
# =============================================================================
#
# Copy assets from the engine to the sandbox.
# CSS is loaded from oroshi.css (built Tailwind) + Bootstrap CDN.
#

# Procfile for development server
echo "ðŸ“‹ Creating Procfile.dev..."
cat > Procfile.dev <<PROCFILE
web: bin/rails server -p 3001
PROCFILE

# Copy vendored JavaScript files from engine
echo "ðŸ“‹ Copying vendored JavaScript files..."
mkdir -p vendor/javascript
cp -r ../vendor/javascript/* vendor/javascript/ 2>/dev/null || true

# Copy compiled CSS from engine
echo "ðŸŽ¨ Copying CSS assets..."
mkdir -p app/assets/builds
cp ../app/assets/builds/oroshi.css app/assets/builds/ 2>/dev/null || true

# Copy application layout (includes Bootstrap CDN and navbar)
echo "ðŸ“„ Copying application layout from gem..."
cp ../app/views/layouts/application.html.erb app/views/layouts/application.html.erb

# Copy migrations from engine
echo "ðŸ“‹ Copying migrations..."
mkdir -p db/migrate
cp -r ../db/migrate/* db/migrate/

# Create directories for Solid schemas
echo "ðŸ“‹ Setting up Solid Queue, Cache, and Cable..."
mkdir -p db/queue_migrate db/cache_migrate db/cable_migrate

# =============================================================================
# USER MODEL (TWO-STAGE CREATION)
# =============================================================================
#
# The User model is created in two stages:
#   1. Minimal version for migrations (migrations may reference User)
#   2. Full Devise version after database setup
#
# This avoids initialization order issues where Devise methods are called
# before the Devise railtie is fully loaded.
#

echo "ðŸ‘¤ Creating minimal User model for migrations..."
cat > app/models/user.rb <<RUBY
class User < ApplicationRecord
  # Minimal model for migrations - Devise configuration added after migrations
end
RUBY

# =============================================================================
# DATABASE SETUP
# =============================================================================
#
# Use db:schema:load instead of db:migrate to avoid executing migration code
# that references Oroshi:: models before the engine is fully initialized.
#
echo "ðŸ—„ï¸  Creating and migrating databases..."

# Drop existing databases for clean slate (ignore errors if they don't exist)
if unbundled bin/rails db:drop 2>/dev/null; then
  unbundled bin/rails db:create
  # Copy and load schema directly (avoids migration code execution)
  cp ../db/schema.rb db/schema.rb
  unbundled bin/rails db:schema:load
else
  unbundled bin/rails db:create
  cp ../db/schema.rb db/schema.rb
  unbundled bin/rails db:schema:load
fi

# Load Solid schemas for queue, cache, and cable databases
unbundled bin/rails db:schema:load:queue
unbundled bin/rails db:schema:load:cache
unbundled bin/rails db:schema:load:cable

# =============================================================================
# FULL USER MODEL
# =============================================================================
#
# Now that databases exist, create the full User model with Devise.
#
echo "ðŸ‘¤ Creating full User model..."
cat > app/models/user.rb <<RUBY
# User Model
# ==========
# Application-level user model with Devise authentication.
# This model is NOT namespaced under Oroshi - it lives at the app level.
# Parent applications can customize this model as needed.

class User < ApplicationRecord
  validates :username, presence: true, uniqueness: { case_sensitive: false }
  validates_format_of :username, with: /\A[a-zA-Z0-9_.]*\z/

  # User roles: user, vip, admin, supplier, employee
  enum :role, { user: 0, vip: 1, admin: 2, supplier: 3, employee: 4 }

  # Oroshi associations
  has_one :onboarding_progress, class_name: "Oroshi::OnboardingProgress", dependent: :destroy

  # Devise modules
  devise :database_authenticatable, :registerable, :confirmable,
         :recoverable, :rememberable, :trackable, :validatable,
         authentication_keys: [:login]

  attr_accessor :login

  # Allow login with either username or email
  def self.find_for_database_authentication(warden_conditions)
    conditions = warden_conditions.dup
    if (login = conditions.delete(:login))
      where(conditions.to_h).where(["lower(username) = :value OR lower(email) = :value", { value: login.downcase }]).first
    elsif conditions.has_key?(:username) || conditions.has_key?(:email)
      where(conditions.to_h).first
    end
  end
end
RUBY

# =============================================================================
# APPLICATION CONTROLLER
# =============================================================================
#
# Set up the ApplicationController with Devise authentication.
#
echo "ðŸŽ® Creating ApplicationController with authentication..."
cat > app/controllers/application_controller.rb <<RUBY
# Application Controller
# ======================
# Base controller for the sandbox application.
# All controllers inherit from this.

class ApplicationController < ActionController::Base
  before_action :authenticate_user!

  # Include Oroshi engine route helpers (oroshi.dashboard_path, etc.)
  helper Oroshi::Engine.routes.url_helpers

  # Only allow modern browsers supporting webp images, web push, badges,
  # import maps, CSS nesting, and CSS :has.
  allow_browser versions: :modern
end
RUBY

# Remove default ApplicationHelper - Oroshi's controllers include their own helpers
echo "ðŸŽ¨ Removing default ApplicationHelper..."
rm -f app/helpers/application_helper.rb

# =============================================================================
# SEED DATA
# =============================================================================
#
# Create demo users for testing.
#
echo "ðŸŒ± Seeding demo data..."
unbundled bin/rails runner "
# Create demo users with different roles
User.insert({
  email: 'admin@oroshi.local',
  username: 'admin',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:admin],
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
User.insert({
  email: 'vip@oroshi.local',
  username: 'vip',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:vip],
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
User.insert({
  email: 'user@oroshi.local',
  username: 'user',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:user],
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
puts 'âœ“ Created demo users'
"

# =============================================================================
# SUCCESS MESSAGE
# =============================================================================

echo ""
echo "âœ… Sandbox application created successfully!"
echo ""
echo "To start the sandbox:"
echo "  cd sandbox"
echo "  bin/dev"
echo ""
echo "Then visit: http://localhost:3001"
echo ""
echo "Demo accounts:"
echo "  Admin: admin@oroshi.local / password123"
echo "  VIP:   vip@oroshi.local / password123"
echo "  User:  user@oroshi.local / password123"
echo ""
