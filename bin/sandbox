#!/usr/bin/env bash
set -e  # Exit on any error
set -u  # Exit on undefined variables
set -o pipefail  # Catch errors in pipes

# Unbundled function - run commands outside the parent's bundler environment
# This is critical for engine development to avoid gem loading conflicts
# Adapted from Solidus: https://github.com/solidusio/solidus/blob/main/bin/sandbox
unbundled() {
  ruby -rbundler -e'
    Gem::Version.new(Bundler::VERSION) < Gem::Version.new("2.1") ?
      abort("The sandbox requires at least Bundler 2.1") :
      Bundler.with_unbundled_env { system(*ARGV) }' -- \
        env BUNDLE_SUPPRESS_INSTALL_USING_MESSAGES=true "$@"
}

# Handle command-line arguments
COMMAND="${1:-create}"

# Show help
show_help() {
  cat <<EOF
Oroshi Sandbox Management

Usage:
  bin/sandbox [command]

Commands:
  create    Create a new sandbox application (default)
  destroy   Remove the sandbox application
  reset     Destroy and recreate the sandbox application
  help      Show this help message

Environment Variables:
  DB        Database adapter (postgresql, mysql) - default: postgresql

Examples:
  bin/sandbox              # Create sandbox
  bin/sandbox reset        # Recreate sandbox
  bin/sandbox destroy      # Remove sandbox
  DB=mysql bin/sandbox     # Create with MySQL

EOF
}

# Destroy sandbox
destroy_sandbox() {
  if [ -d "./sandbox" ]; then
    echo "üßπ Removing sandbox..."
    rm -rf ./sandbox
    echo "‚úÖ Sandbox removed"
  else
    echo "‚ÑπÔ∏è  No sandbox found"
  fi
}

# Handle commands
case "$COMMAND" in
  help|-h|--help)
    show_help
    exit 0
    ;;
  destroy)
    destroy_sandbox
    exit 0
    ;;
  reset)
    destroy_sandbox
    # Continue to create
    ;;
  create)
    # Continue to create
    ;;
  *)
    echo "‚ùå Unknown command: $COMMAND"
    echo "Run 'bin/sandbox help' for usage"
    exit 1
    ;;
esac

echo "üèóÔ∏è  Creating Oroshi sandbox application..."

# Detect database from environment (default to postgresql if not set)
DB="${DB:-postgresql}"

case "$DB" in
  postgres|postgresql)
    RAILSDB="postgresql"
    ;;
  mysql)
    RAILSDB="mysql"
    ;;
  *)
    RAILSDB="postgresql"
    ;;
esac

# Clean slate
if [ -d "./sandbox" ]; then
  echo "üßπ Removing existing sandbox..."
  rm -rf ./sandbox
fi

# Get the absolute path to the oroshi root directory
OROSHI_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Generate fresh Rails app in a temporary location
echo "üì¶ Generating new Rails application..."
TEMP_DIR=$(mktemp -d)
cd "$TEMP_DIR"

rails new sandbox \
  --database="$RAILSDB" \
  --skip-git \
  --skip-keeps \
  --skip-rc \
  --skip-test \
  --css=tailwind \
  --javascript=importmap

# Move the generated app to the oroshi directory
mv sandbox "$OROSHI_ROOT/"
cd "$OROSHI_ROOT/sandbox"

# Clean up temp directory
rm -rf "$TEMP_DIR"

# Add CSS processing gems before Oroshi
echo "üìù Adding CSS processing gems to Gemfile..."
# Insert dartsass-rails and bootstrap after tailwindcss-rails
sed -i.bak '/gem "tailwindcss-rails"/a\
# Use Dart Sass for stylesheets [https://github.com/rails/dartsass-rails]\
gem "dartsass-rails"\
# Use Bootstrap for styling [https://github.com/twbs/bootstrap-rubygem]\
gem "bootstrap", "~> 5.3"
' Gemfile
rm Gemfile.bak

# Add Oroshi and development gems to Gemfile
echo "üìù Adding Oroshi to Gemfile..."
cat <<RUBY >> Gemfile

# Oroshi engine (local development) - must be loaded in all environments
gem "oroshi", path: "..", require: "oroshi"

# Required dependencies
gem "listen", "~> 3.3"

# Development tools
group :development, :test do
  gem "rspec-rails"
  gem "factory_bot_rails"
end

group :development do
  gem "better_errors"
  # binding_of_caller not compatible with Ruby 4.0
  # gem "binding_of_caller"
end
RUBY

# Bundle install (unbundled to avoid inheriting parent's gem environment)
echo "üì¶ Installing gems..."
unbundled bundle install --quiet

# Configure dartsass
echo "üé® Configuring Dart Sass..."
unbundled bin/rails dartsass:install

# Fix Procfile.dev to use unique process names
echo "üîß Fixing Procfile.dev..."
cat > Procfile.dev <<PROCFILE
web: bin/rails server
tailwind: bin/rails tailwindcss:watch
sass: bin/rails dartsass:watch
PROCFILE

# Create proper application.scss that imports Oroshi engine styles
echo "üìù Creating application.scss..."
cat > app/assets/stylesheets/application.scss <<'SCSS'
/*
 * Sandbox Application Stylesheet
 *
 * Imports all Oroshi engine styles
 */

// Bootstrap 5
@use "sass:map";
@import "oroshi";
@import "bootstrap";
@import url("https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css");
@import url("https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css");

// Oroshi engine styles
@import "scaffolds";
@import "flatpickr/flatpickr";
@import "oroshi_utilities";
@import "onboarding";
@import "controllers/application";
SCSS

# Build CSS
echo "üèóÔ∏è  Building Sass..."
unbundled bin/rails dartsass:build

# Remove sandbox's application layout so engine layout is used
echo "üóëÔ∏è  Removing sandbox application layout (will use engine's layout)..."
rm -f app/views/layouts/application.html.erb

# Configure Oroshi (do this AFTER bundle install so Oroshi is loaded)
echo "‚öôÔ∏è  Configuring Oroshi..."
cat > config/initializers/oroshi.rb <<RUBY
if defined?(Oroshi)
  Oroshi.configure do |config|
    config.time_zone = "Asia/Tokyo"
    config.locale = :ja
    config.domain = ENV.fetch("OROSHI_DOMAIN", "localhost")
  end

  Rails.application.config.time_zone = Oroshi.configuration.time_zone
  Rails.application.config.active_record.default_timezone = :utc
  Rails.application.config.i18n.default_locale = Oroshi.configuration.locale
  Rails.application.config.i18n.available_locales = [:ja, :en]
end
RUBY

# Create Devise initializer
echo "üîê Configuring Devise..."
cat > config/initializers/devise.rb <<'RUBY'
if defined?(Devise)
  Devise.setup do |config|
    config.secret_key = Rails.application.credentials.secret_key_base || ENV.fetch('DEVISE_KEY', 'sandbox_dev_key')
    config.mailer_sender = ENV.fetch('MAIL_SENDER', 'noreply@localhost')
    config.mailer = 'Devise::Mailer'
    config.parent_mailer = 'ActionMailer::Base'
    require 'devise/orm/active_record'
    config.authentication_keys = [:login]
    config.case_insensitive_keys = [:email]
    config.strip_whitespace_keys = [:email]
    config.skip_session_storage = [:http_auth]
    config.stretches = Rails.env.test? ? 1 : 11
    config.send_email_changed_notification = false
    config.send_password_change_notification = false
    config.confirm_within = 3.days
    config.reconfirmable = false
    config.confirmation_keys = [:email]
    config.expire_all_remember_me_on_sign_out = true
    config.password_length = 6..128
    config.email_regexp = /\A[^@\s]+@[^@\s]+\z/
    config.scoped_views = true
    config.sign_out_via = :delete
  end
end
RUBY

# Setup routes - mount Oroshi engine
echo "üîå Setting up routes..."
cat > config/routes.rb <<'RUBY'
Rails.application.routes.draw do
  # Health check for Kamal
  get "up" => "rails/health#show", as: :rails_health_check

  # Devise routes (User model is app-level, not engine-level)
  devise_for :users, controllers: { sessions: "users/sessions", registrations: "users/registrations" } if respond_to?(:devise_for)

  # Mount Oroshi engine at root
  mount Oroshi::Engine, at: "/"

  # Root redirects to Oroshi dashboard
  root to: redirect("/dashboard")
end
RUBY

# Copy database configuration for multi-database setup
echo "üóÑÔ∏è  Configuring multi-database setup..."
cat > config/database.yml <<YAML
default: &default
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  host: localhost
  username: <%= ENV.fetch("POSTGRES_USER", "postgres") %>
  password: <%= ENV.fetch("POSTGRES_PASSWORD", "") %>

development:
  primary:
    <<: *default
    database: oroshi_sandbox_development
  queue:
    <<: *default
    database: oroshi_sandbox_development_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_development_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_development_cable
    migrations_paths: db/cable_migrate

test:
  primary:
    <<: *default
    database: oroshi_sandbox_test
  queue:
    <<: *default
    database: oroshi_sandbox_test_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_test_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_test_cable
    migrations_paths: db/cable_migrate

production:
  primary:
    <<: *default
    database: oroshi_sandbox_production
  queue:
    <<: *default
    database: oroshi_sandbox_production_queue
    migrations_paths: db/queue_migrate
  cache:
    <<: *default
    database: oroshi_sandbox_production_cache
    migrations_paths: db/cache_migrate
  cable:
    <<: *default
    database: oroshi_sandbox_production_cable
    migrations_paths: db/cable_migrate
YAML

# Create Procfile.dev for development
echo "üìã Creating Procfile.dev..."
cat > Procfile.dev <<PROCFILE
web: bin/rails server -p 3000
css: bin/rails tailwindcss:watch
PROCFILE

# Copy vendored JavaScript files from engine
echo "üìã Copying vendored JavaScript files..."
mkdir -p vendor/javascript
cp -r ../vendor/javascript/* vendor/javascript/ 2>/dev/null || true

# Build Tailwind CSS (one-time build for initial setup)
echo "üé® Building Tailwind CSS..."
unbundled bin/rails tailwindcss:build 2>/dev/null || echo "  Tailwind build skipped (will build on server start)"

# Copy Solid schemas
echo "üìã Setting up Solid Queue, Cache, and Cable..."
mkdir -p db/queue_migrate db/cache_migrate db/cable_migrate

# Create minimal User model for migrations (migrations reference User model)
echo "üë§ Creating minimal User model for migrations..."
cat > app/models/user.rb <<RUBY
class User < ApplicationRecord
  # Minimal model for migrations - Devise configuration added after migrations
end
RUBY

# Setup databases (use unbundled to ensure clean gem environment)
echo "üóÑÔ∏è  Creating and migrating databases..."
# Try to drop and recreate (for clean slate), fall back to create if databases don't exist
if unbundled bin/rails db:drop 2>/dev/null; then
  unbundled bin/rails db:create
  # Use schema:load instead of migrate to avoid migration code execution issues
  cp ../db/schema.rb db/schema.rb
  unbundled bin/rails db:schema:load
else
  unbundled bin/rails db:create
  cp ../db/schema.rb db/schema.rb
  unbundled bin/rails db:schema:load
fi
unbundled bin/rails db:schema:load:queue
unbundled bin/rails db:schema:load:cache
unbundled bin/rails db:schema:load:cable

# Remove migration files after schema load to prevent pending migration warnings
# Since we loaded the schema directly, we don't need the individual migrations
echo "üßπ Cleaning up migration files..."
rm -rf db/migrate/*

# Now create full User model with Devise configuration
echo "üë§ Creating full User model..."
cat > app/models/user.rb <<RUBY
class User < ApplicationRecord
  validates :username, presence: true, uniqueness: { case_sensitive: false }
  validates_format_of :username, with: /\A[a-zA-Z0-9_.]*\z/

  enum :role, { user: 0, vip: 1, admin: 2, supplier: 3, employee: 4 }

  has_one :onboarding_progress, class_name: "Oroshi::OnboardingProgress", dependent: :destroy

  devise :database_authenticatable, :registerable, :confirmable,
         :recoverable, :rememberable, :trackable, :validatable,
         authentication_keys: [:login]

  attr_accessor :login

  def self.find_for_database_authentication(warden_conditions)
    conditions = warden_conditions.dup
    if (login = conditions.delete(:login))
      where(conditions.to_h).where(["lower(username) = :value OR lower(email) = :value", { value: login.downcase }]).first
    elsif conditions.has_key?(:username) || conditions.has_key?(:email)
      where(conditions.to_h).first
    end
  end
end
RUBY

# Create ApplicationController with Devise authentication
echo "üéÆ Creating ApplicationController with authentication..."
cat > app/controllers/application_controller.rb <<RUBY
class ApplicationController < ActionController::Base
  before_action :authenticate_user!

  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.
  allow_browser versions: :modern
end
RUBY

# Remove default ApplicationHelper - Oroshi's controllers include their own helpers
echo "üé® Removing default ApplicationHelper..."
rm -f app/helpers/application_helper.rb

# Seed demo users
echo "üå± Seeding demo users..."
unbundled bin/rails runner "
User.insert({
  email: 'admin@oroshi.local',
  username: 'admin',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:admin],
  approved: true,
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
User.insert({
  email: 'vip@oroshi.local',
  username: 'vip',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:vip],
  approved: true,
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
User.insert({
  email: 'user@oroshi.local',
  username: 'user',
  encrypted_password: Devise::Encryptor.digest(User, 'password123'),
  role: User.roles[:user],
  approved: true,
  confirmed_at: Time.current,
  created_at: Time.current,
  updated_at: Time.current
})
puts '‚úì Created 3 demo users'
"

# Seed comprehensive demo data
echo "üå± Seeding comprehensive demo data (this may take a minute)..."
DEMO_DATA=true unbundled bin/rails runner "
  demo_seed_file = Oroshi::Engine.root.join('db', 'seeds', 'demo_data.rb')
  load demo_seed_file if File.exist?(demo_seed_file)
"

echo "‚úì Demo data seeded successfully!"

echo ""
echo "‚úÖ Sandbox application created successfully!"
echo ""
echo "To start the sandbox:"
echo "  cd sandbox"
echo "  bin/dev"
echo ""
echo "Then visit: http://localhost:3000"
echo ""
echo "Demo accounts:"
echo "  Admin: admin@oroshi.local / password123"
echo "  VIP:   vip@oroshi.local / password123"
echo "  User:  user@oroshi.local / password123"
echo ""
